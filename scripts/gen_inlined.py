# This script generates wrapper functions for inlined functions so that they
# can be imported in another language.

from pycparser import c_parser, c_ast, parse_file, c_generator
from pycparser.c_ast import *
import os

generator = c_generator.CGenerator()

gen_out = ""
func_list = []
class FuncDefVisitor(c_ast.NodeVisitor):
    def visit_FuncDef(self, node):
        global gen_out
        global func_list

        if 'inline' in node.decl.funcspec:

            func_list += [node.decl.name]

            out = " {\n    return "
            out += node.decl.name + "("
            first = True
            for p in node.decl.type.args.params:
                if not first:
                    out += ", "
                out += p.name
                first = False
            out += ");\n}\n"

            node.decl.storage = [] # remove static
            node.decl.funcspec = [] # remove inline

            if type(node.decl.type.type) == PtrDecl:
                node.decl.type.type.type.declname += "_inline"
            elif type(node.decl.type.type) == TypeDecl:
                node.decl.type.type.declname += "_inline"
            else:
                raise

            gen_out += generator.visit(node.decl) + out

def list_all_headers():
    out = ""
    for root, dirs, files in os.walk("lvgl"):
        root = root[5:] # remove lvgl root dir
        for file in files:
            if file.endswith(".h") and not "templ" in file:
                out += '#include "' + os.path.join(root, file) + '"\n'
    return out


def gen_inline_wrappers(filename):
    ast = parse_file(filename, use_cpp=True,
                     cpp_args=['-Itmp/pycparser/utils/fake_libc_include',
                               '-Iscripts',
                               '-Ilvgl',
                               '-DLV_CONF_INCLUDE_SIMPLE'])

    v = FuncDefVisitor()
    v.visit(ast)

def print_warn(file, line_nbr, func):
    print "src/%s:%d: function '%s' is inlined, pragma Import should use '%s_inline'" % (file, line_nbr, func, func)

def check_ada_imports(func_list):
    # Find all pragma import and check if the symbol used is an inline
    # function, in that case print an error message

    for root, dirs, files in os.walk("src"):
        for file in files:
            if file.endswith(".ads") or file.endswith(".adb") :
                with open(os.path.join(root, file), "r") as f:
                    line_nbr = 0
                    for line in f.readlines():
                        line_nbr += 1
                        if "pragma Import" in line: # Filter pragma import lines
                            func = line.split('"')[1] # extract symbol
                            if func in func_list:
                                print_warn(file, line_nbr, func)


# Clone the pycparser repository to get the fake libc headers
os.system("git clone git@github.com:eliben/pycparser.git tmp/pycparser")

# List all the headers of LVGL
headers = list_all_headers();

# Filename of the c file that will be generated
filename = "src/import_inline.c";

# Write the headers include
with open(filename, "w") as f:
    f.write(headers)

# Generate wrappers calling inline functions
gen_inline_wrappers(filename)

# Concatenate headers and generated functions
with open(filename, "w") as f:
    f.write ("// This file was generated by script/gen_inlined.py\n")
    f.write(headers)
    f.write("\n")
    f.write(gen_out)

# Check is ada imports use the right function name
check_ada_imports(func_list)
